package de.lehmann.lehmannorm.logic.sqlbuilder;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import de.lehmann.lehmannorm.AConnectionUnitTest;
import de.lehmann.lehmannorm.models.TestTableEntity;
import de.lehmann.lehmannorm.stubs.ConnectionStub;
import de.lehmann.lehmannorm.stubs.PreparedStatementStub;

public class DefaultStatementBuilderUnitTest extends AConnectionUnitTest {

    private static TestTableEntity entity;

    @BeforeAll
    public static void createExampleEntity() throws InstantiationException, IllegalAccessException, SQLException {

        entity = new TestTableEntity();
        entity.setPrimaryKeyValue(6);
        entity.setColumnValue(TestTableEntity.NUMBER, 1d);
        entity.setColumnValue(TestTableEntity.DESCRIPTION, "Eine andere Beschreibung.");
    }

    public static Object[][] parameters() {

        final IStatementBuilder insertStatementBuilder =
                IStatementBuilder.DefaultBuilderBundle.DEFAULT_INSERT_STATEMENT_BUILDER.getStatementBuilder();
        final IStatementBuilder selectStatementBuilder =
                IStatementBuilder.DefaultBuilderBundle.DEFAULT_SELECT_STATEMENT_BUILDER.getStatementBuilder();

        return new Object[][] { {
                insertStatementBuilder,
                "INSERT INTO TEST_TABLE(ID,NUMBER,DESCRIPTION) VALUES(?,?,?);"
        }, {
                selectStatementBuilder,
                "SELECT ID,NUMBER,DESCRIPTION FROM TEST_TABLE WHERE ID=?;"
        } };
    }

    @MethodSource(value = "parameters")
    @ParameterizedTest
    public void testString(final IStatementBuilder toTest, final String expected) throws SQLException {

        final PreparedStatement preparedStatement =
                toTest.buildStatement(entity.getTableName(), entity.getAllColumns().keySet(), connection);

        final String actual = preparedStatement.toString(); // toString returns the sqlString

        assertEquals(expected, actual);
    }

    @Override
    protected Connection createConnection() throws SQLException {

        return new ConnectionMock();
    }

    /*********
     * MOCKs *
     *********/

    private static class ConnectionMock extends ConnectionStub {

        @Override
        public PreparedStatement prepareStatement(final String sql) throws SQLException {

            return new PreparedStatementMock(sql);
        }

        @Override
        public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {

            return prepareStatement(sql);
        }
    }

    private static class PreparedStatementMock extends PreparedStatementStub {

        private final String sqlString;

        public PreparedStatementMock(final String sqlString) {

            this.sqlString = sqlString;
        }

        @Override
        public String toString() {

            return sqlString;
        }
    }
}
